[[processors.starlark]]
# MIB filename - ENTITY-MIB.mib
# MIB name - ENTITY-MIB
source = '''
def apply(metric):

    #============= entConfigChange ===============================
    if metric.tags["name"] == "entConfigChange":
        
        # There are no varbinds mapped for the trap.
        

        # Adapt the following code to suit the individual Notification.
        metric.fields["agent"] = metric.tags["mib"]
        metric.fields["alertgroup"] = metric.tags["name"]
        metric.fields["alertkey"] = ""
        metric.fields["class"] = "IETF ENTMIB Working Group"
        metric.fields["eventid"] = ""
        metric.fields["firstoccurence"] = ""
        metric.fields["fqdn"] = ""
        metric.fields["node"] = metric.tags["source"]
        metric.fields["severity"] = ""
        metric.fields["summary"] = "An entConfigChange notification is generated when the valueof entLastChangeTime changes.  It can be utilized by an NMSto trigger logicalphysical entity table maintenance polls.An agent should not generate more than one entConfigChangenotificationevent in a given time interval (five secondsis the suggested default).  A notificationevent is thetransmission of a single trap or inform PDU to a list ofnotification destinations.If additional configuration changes occur within thethrottling period then notificationevents for thesechanges should be suppressed by the agent until the currentthrottling period expires.  At the end of a throttlingperiod one notificationevent should be generated if anyconfiguration changes occurred since the start of thethrottling period.  In such a case another throttlingperiod is started right away.An NMS should periodically check the value ofentLastChangeTime to detect any missed entConfigChangenotificationevents e.g. due to throttling or transmissionloss."
        
    
    return metric 
'''